# -*- coding: utf-8 -*-
"""custom_dataset_class.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZShN0ZA_zwrN1rPsdW81Ezi1IsUbVHdW
"""

from torch.utils.data import Dataset
import torch.nn as nn
import torch
import torch.nn.functional as F
import torchvision.transforms as transforms
import numpy as np
from transformers import ViTImageProcessor

class CIFAKEDataset(torch.utils.data.Dataset): # customized dataset for CIFAKE
  def __init__(self, dataset, transform=None):
    self.dataset = dataset # should be train or test split in CIFAKE dataset
    self.transform = transform

  def __len__(self):
    return len(self.dataset)

  def __getitem__(self, idx):
    image = self.dataset[idx]['image']
    label = self.dataset[idx]['label']
    if self.transform:
      image = self.transform(image)
    else:
      transform = transforms.Compose([
        transforms.ToTensor()
      ])
      image = transform(image)
    label = torch.tensor(label).float()

    return {'image':image,'label':label}

class CIFAKEDataset_Blur(CIFAKEDataset):
  '''
  gaussian blurred CIFAKE dataset
  '''
  def __init__(self, dataset, transform=None, kernal_size=None, sigma=None):
    super().__init__(dataset, transform)
    self.kernal_size = kernal_size
    self.sigma = sigma

  def __getitem__(self, idx):
    image = self.dataset[idx]['image']
    label = self.dataset[idx]['label']
    if self.transform:
      image = self.transform(image)
    else:
      if self.kernal_size and self.sigma:
        transform = transforms.Compose([
          transforms.ToTensor(),
          transforms.GaussianBlur(kernel_size=self.kernal_size, sigma=self.sigma)

        ])
      else:
        transform = transforms.Compose([
          transforms.ToTensor(),
          transforms.GaussianBlur(kernel_size=(3,5), sigma=(0.4,0.6))
        ])

      image = transform(image)

    image = torch.clamp(image,0.0,1.0)
    label = torch.tensor(label).float()
    return {'image':image,'label':label}

class CIFAKEDataset_ViT_scaled(CIFAKEDataset):
  '''
  scales the PiL images to (C, 224, 224)
  '''
  def __init__(self, dataset, transform=None, processor=ViTImageProcessor.from_pretrained('google/vit-base-patch16-224')):
    super().__init__(dataset, transform)
    self.processor = processor

  def __getitem__(self, idx):
    image = self.dataset[idx]['image'] # PiL image
    label = self.dataset[idx]['label']
    if self.transform:
      image = self.transform(image)
    else:
      transform = transforms.Compose([
        transforms.ToTensor()
      ])
      image = transform(image) # (C, 32, 32) in [0,1]
      image = self.processor(image, return_tensors='pt', do_rescale=False)['pixel_values'] # (1, C, 224, 224)
      image = torch.squeeze(image) # (C, 224, 224)
    label = torch.tensor(label).float()
    return {'image':image,'label':label}

class CIFAKEDataset_ViT_scaled_Blur(CIFAKEDataset_Blur):
  '''
  scales the images to (C, 224, 224) with gaussian blur
  '''
  def __init__(self, dataset, transform=None, kernal_size=None, sigma=None, processor=ViTImageProcessor.from_pretrained('google/vit-base-patch16-224')):
    super().__init__(dataset, transform, kernal_size, sigma)
    self.processor = processor


  def __getitem__(self, idx):
    image = self.dataset[idx]['image']
    label = self.dataset[idx]['label']
    if self.transform:
      image = self.transform(image)
    else:
      if self.kernal_size and self.sigma:
        transform = transforms.Compose([
          transforms.ToTensor(),
          transforms.GaussianBlur(kernel_size=self.kernal_size, sigma=self.sigma)
        ])
        
      else:
        transform = transforms.Compose([
          transforms.ToTensor(),
          transforms.GaussianBlur(kernel_size=(3,5), sigma=(0.4,0.6))
        ])
      image = transform(image) 
      image = torch.clamp(image,0.0,1.0) # (C, 32, 32) in [0,1]
      image = self.processor(image, return_tensors='pt', do_rescale=False)['pixel_values'] # (1, C, 224, 224)
      image = torch.squeeze(image) # (C, 224, 224)
    label = torch.tensor(label).float()
    return {'image':image,'label':label}
